-------------------------Merge Sort--------------------------

#include <iostream>
#include <vector>

using namespace std;

void merge(vector<int>& arr,int start,int mid,int end){
    int length1 = mid-start+1;
    int length2 = end-mid;

    vector<int> arr1(length1);
    vector<int> arr2(length2);

    int k = start;
    for(int i=0;i<length1;i++){
        arr1[i] = arr[k++];
    }
    k = mid+1;
    for(int i=0;i<length2;i++){
        arr2[i] = arr[k++];
    }

    int i = 0;
    int j = 0;
    k = start;

    while(i < length1 && j < length2){
        if(arr1[i] <= arr2[j]) arr[k++] = arr1[i++];
        else arr[k++] = arr2[j++];
    }

    while(i < length1) arr[k++] = arr1[i++];

    while(j < length2) arr[k++] = arr2[j++];
}

void mergeSort(vector<int>& arr,int start,int end){
    if(start >= end) return ;

    int mid = start + (end-start)/2;
    mergeSort(arr,start,mid);
    mergeSort(arr,mid+1,end);

    merge(arr,start,mid,end);
}

int main(){

    int n;
    cin>>n;

    vector<int> arr(n);
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }

    int start = 0;
    int end = n-1;

    mergeSort(arr,start,end);

    for(int i=0;i<n;i++){
        cout<<arr[i]<<" ";
    }cout<<endl;

    return 0;
}


--------------------------MAX SUM SUBARRAY NOT CONTINIOUS-----------------------------
#include <iostream>
#include <vector>

using namespace std;

void sort(vector<int>& arr){
    int n = arr.size();
    for(int i=0;i<n;i++){
        for(int j=0;j<n-1;j++){
            if(arr[j] >= arr[j+1]) swap(arr[j],arr[j+1]);
        }
    }
}

int main(){

    int n;
    cin>>n;

    vector<int> arr(n);
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }

    sort(arr);
    int sum = 0;

    for(int i=0;i<n;i++){
        if(arr[i] >= 0){
            sum += arr[i];
        }
    }

    cout<<sum<<endl;

    return 0;
}

-----------------------MAX SUB ARRAY CONTINIOUS--------------------------
#include <iostream>
#include <vector>
#include <limits>

using namespace std;

int main(){

    int n;
    cin>>n;

    vector<int> arr(n);
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }

    int maxSum = INT_MIN;
    int currentSum = 0;

    for(int i=0;i<n;i++){
        currentSum += arr[i];
        if(currentSum >= maxSum){
            maxSum = currentSum;
        }
        if(currentSum < 0) currentSum = 0;
    }

    cout<<maxSum<<endl;

    return 0;
}

-----------------------------------MATRIX CHAIN MULTIPLICATION--------------------------
#include <vector>
#include <iostream>
#include <limits>

using namespace std;

int matrixChainMemoised(vector<int> arr,int i,int j,vector<vector<int>>& dp){
    if(i == j){
        return 0;
    }

    if(dp[i][j] != -1){
        return dp[i][j];
    }

    dp[i][j] = INT_MAX;
    for(int k=i;k<j;k++){
        int ans = matrixChainMemoised(arr,i,k,dp) + matrixChainMemoised(arr,k+1,j,dp) + arr[i-1]*arr[j]*arr[k];
        if(ans < dp[i][j]) dp[i][j] = ans;
    }

    return dp[i][j];
}

int MatrixChainMultiplication(vector<int> arr,int n,vector<vector<int>>& dp){
    int i = 1;
    int j = n-1;

    return matrixChainMemoised(arr,i,j,dp);
}

int main(){

    int n;
    cin>>n;

    vector<int> arr(n+1);
    for(int i=0;i<=n;i++){
        cin>>arr[i];
    }

    vector<vector<int>> dp(n+1,vector<int>(n+1,-1));

    int answer = MatrixChainMultiplication(arr,n+1,dp);
    cout<<answer<<endl;

    return 0;
}


---------------------------------- LCS ----------------------------------

#include <vector>
#include <iostream>

using namespace std;

int main(){

    string text,pattern;
    cin>>text>>pattern;

    int n = text.length()+1;
    int m = pattern.length()+1;

    vector<vector<int>> dp(n,vector<int>(m,0));

    // dirn
    // 0 diagonal
    // 1 left
    // 2 up

    for(int i=1;i<n;i++){
        for(int j=1;j<m;j++){

            if(text[i-1] == pattern[j-1]){
                dp[i][j] = dp[i-1][j-1] + 1;
            }
            else{
                if(dp[i][j-1] >= dp[i-1][j]){
                    dp[i][j] = dp[i][j-1];
                }
                else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
    }

    cout<<"length of longest common sequence "<<dp[n-1][m-1]<<endl;

    return 0;
}


--------------------------------------------------------- 0/1 KNAPSACK ----------------------------------------
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class article{
    public:
        int price,weight;
        float pricePerWeight;

        void set(int price,int weight){
            this->price = price;
            this->weight = weight;

            pricePerWeight = (float)(price/weight);
        }
};

bool great(article a1,article a2){
    if(a1.pricePerWeight >= a2.pricePerWeight) return true;
    return false;
}

int main(){

    int n,weightCarry;
    cin>>n>>weightCarry;

    vector<article> arr(n);
    for(int i=0;i<n;i++){
        int price,weight;
        cin>>price>>weight;

        arr[i].set(price,weight);
    }

    sort(arr.begin(),arr.end(),great);

    int price = 0;
    int weight = 0;
    for(auto i:arr){
        if(weight + i.weight >= weightCarry){
            weight += i.weight;
            price += i.price;
        }
    }

    cout<<price<<endl;

    return 0;
}

-------------------------------------- N QUEENS ------------------------------------
#include <iostream>
#include <vector>

using namespace std;

bool isSafe(int row,int col,vector<string>&board,int n){
    int r = row;
    int c = col;
    // checking upward diagonal
    while(r>=0 && c>=0){
        if(board[r][c]=='Q'){
            return false;
        }
        r--,c--;
    }


    // checking row
    r=row;
    c= col;
    while(c>=0){
        if(board[r][c]=='Q'){
            return false;
        }
        c--;
    }
    
    // checking lower diagonal
    r=row;
    c=col;
    while(r<n && c>=0){
        if(board[r][c]=='Q'){
            return false;
        }
        r++;
        c--;
    }
    
    return true;

}
void solve(int col,vector<string>&board,vector<vector<string>> &ans,int n){
    if(col==n){
        ans.push_back(board);
        return;
    }

    for(int row=0;row<n;row++){
        if(isSafe(row,col,board,n)){
            board[row][col]='Q';
            solve(col+1,board,ans,n);
            board[row][col]='.';
        }
    }
}
vector<vector<string>> solveNQueens(int n) {
    vector<vector<string>> ans;
    vector<string> board(n);
    string s(n,'.');
    for(int i=0;i<n;i++){
        board[i]=s;
    }

    solve(0,board,ans,n);
    return ans;
}

int main(){

    int n;
    cin>>n;

    vector<vector<string>> answer = solveNQueens(n);

    for(auto i:answer){
        for(auto j:i){
            cout<<j<<endl;
        }cout<<endl;
    }

    return 0;
}

----------------------------------------- SUB SET SUM ------------------------------
#include <iostream>
#include <vector>

using namespace std;

bool isSubsetSumRecursive(const vector<int>& nums, int targetSum, int index, int currentSum) {
    if (currentSum == targetSum) {
        return true;
    }

    if (currentSum > targetSum || index >= nums.size()) {
        return false;
    }

    // Include the current element in the subset and check
    if (isSubsetSumRecursive(nums, targetSum, index + 1, currentSum + nums[index])) {
        return true;
    }

    // Exclude the current element from the subset and check
    if (isSubsetSumRecursive(nums, targetSum, index + 1, currentSum)) {
        return true;
    }

    return false;
}

bool subsetSum(const vector<int>& nums, int targetSum) {
    return isSubsetSumRecursive(nums, targetSum, 0, 0);
}

int main() {

    int n,targetSum;
    cin>>n>>targetSum;

    vector<int> nums(n);
    for(int i=0;i<n;i++){
        cin>>nums[i];
    }

    if (subsetSum(nums, targetSum)) {
        cout << "Subset with the given sum exists." << endl;
    } else {
        cout << "No subset with the given sum exists." << endl;
    }

    return 0;
}

